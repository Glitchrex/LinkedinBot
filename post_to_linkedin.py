import sys
import os
import time
from pathlib import Path
import hashlib
import re
from playwright.sync_api import sync_playwright, TimeoutError

# Use a single reusable user folder (override with USER_DIR env var)
USER_DIR = os.getenv("USER_DIR", "user")
POSTED_LOG = "posted.log"

# Load latest post from shared user folder
posts_dir = Path(f"{USER_DIR}/posts")

if not posts_dir.exists():
    raise Exception(f"‚ùå Posts directory not found: {posts_dir}")

post_files = sorted(posts_dir.glob("*.txt"))

if not post_files:
    raise Exception("‚ùå No post files found")

def content_hash(text: str) -> str:
    return hashlib.sha256(text.encode("utf-8")).hexdigest()

def already_posted(hash_value: str) -> bool:
    if not Path(POSTED_LOG).exists():
        print(f"‚ÑπÔ∏è {POSTED_LOG} doesn't exist yet")
        return False
    with open(POSTED_LOG, "r") as f:
        content = f.read()
        print(f"‚ÑπÔ∏è Checking against {POSTED_LOG}: {content.strip()}")
        return hash_value in content

def mark_posted(hash_value: str):
    with open(POSTED_LOG, "a") as f:
        f.write(hash_value + "\n")

latest_post = post_files[-1]

with open(latest_post, "r", encoding="utf-8") as f:
    post_text = f.read().strip()

if not post_text:
    raise Exception("‚ùå Post content is empty")

# Check for duplicates BEFORE opening browser
# Try to read hash embedded in filename (generated by generate_post.py).
m = re.search(r"-([0-9a-fA-F]{64})\.txt$", latest_post.name)
if m:
    post_hash = m.group(1)
    print(f"üîç Post hash (from filename): {post_hash}")
else:
    post_hash = content_hash(post_text)
    print(f"üîç Post hash (computed): {post_hash}")
print(f"üìÑ Latest post file: {latest_post}")

if already_posted(post_hash):
    print("‚ö†Ô∏è This post has already been published. Skipping.")
    sys.exit(0)

print("‚úÖ New post detected, proceeding to post...")

# Playwright automation
with sync_playwright() as p:
    browser = p.chromium.launch(
        headless=False,
        slow_mo=50
    )

    context = browser.new_context(storage_state="auth.json")
    page = context.new_page()

    print("‚û°Ô∏è Opening LinkedIn feed...")
    page.goto(
        "https://www.linkedin.com/feed/",
        wait_until="domcontentloaded",
        timeout=60000
    )

    time.sleep(5)

    # Session check
    if "login" in page.url:
        raise Exception("‚ùå Not logged in. Run login_once.py again.")

    # STEP 1: Click "Start a post"
    print("‚û°Ô∏è Opening post composer...")
    try:
        page.get_by_text("Start a post", exact=True).click(timeout=30000, force=True)
        print("‚úÖ Post composer opened")
    except TimeoutError:
        raise Exception("‚ùå Could not find 'Start a post'")

    time.sleep(3)

    # STEP 2: Wait for editor
    print("‚û°Ô∏è Waiting for post editor...")
    try:
        editor = page.get_by_role(
            "textbox",
            name="Text editor for creating content"
        )
        editor.wait_for(timeout=30000)
        editor.click(force=True)
    except TimeoutError:
        raise Exception("‚ùå Post editor did not appear")

    editor = page.locator("div[contenteditable='true']").first
    editor.click()
    time.sleep(1)

    # STEP 3: Type content
    print("‚û°Ô∏è Typing post content...")
    page.keyboard.type(post_text, delay=12)
    time.sleep(5)

    # STEP 4: Click Post
    print("‚û°Ô∏è Publishing post...")
    page.get_by_text("Post", exact=True).click(timeout=30000, force=True)
    print("‚úÖ Post published successfully")
    
    # Mark post as published
    mark_posted(post_hash)
    print(f"üìù Hash recorded in posted.log: {post_hash}")

    # Delete the posted file
    latest_post.unlink()
    print(f"üóëÔ∏è Deleted posted file: {latest_post}")

    time.sleep(15)
    browser.close()





